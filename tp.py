# -*- coding: utf-8 -*-
"""TP

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1PncMg5ActLsDGB6t4B4JGyxh-m4c7rnq
"""

!git clone https://github.com/lmcanavals/algorithmic_complexity.git 2>/dev/null
import random
import numpy as np
import networkx as nx
from sys import maxsize
from itertools import permutations
from algorithmic_complexity.aclib import graphstuff as gs
from math import acos,cos,sin,radians
from cmath import sqrt
import math

lista_todos=[]
#lista_distritos=[]
#lista_centro_poblados=[]
def read_lines(linea:str,lista):
  atributo=linea.split(",")
  place=[atributo[0],atributo[1],atributo[2],atributo[3],float(atributo[4]),float(atributo[5])]
  lista.append(place)
def mostrar_departamentos(lista):
  for i in lista:
    print(i)
def leer_hoja(lista):
  text_name="ubicaciones.txt"  
  with open(text_name)as obj:
    for line in obj:
      read_lines(line,lista)
def distancia_puntos(punto_1,punto_2):
  #p1 = (radians(punto_1[4]),radians(punto_1[5]))
  #p2 = (radians(punto_2[4]),radians(punto_2[5]))
  #distancia = acos(sin(p1[0])*sin(p2[0])+ cos(p1[0]) * cos(p2[0])*cos(p1[1]-p2[1]))
  #return distancia*6371.01
  p1 = (punto_1[4],punto_1[5])
  p2 = (punto_2[4],punto_2[5])
  d=(p1[0]-p2 [0])**2+(p1[1]-p2 [1])**2
  distancia = math.sqrt(d)
  return distancia
  

def agregar_todos_distritos(departamento,provincia,lista_t,lista_d):
  conjunto=[]
  for i in range(len(lista_t)):
    if (departamento==lista_t[i][0] and provincia==lista_t[i][1]):
      lista_d.append(lista_t[i])
      conjunto.append(lista_t[i][2]) 
  return conjunto

def TSP(graph, s):
    vertex = []
    for i in range(len(graph)):
        if i != s:
            vertex.append(i)
    min_path = maxsize
    next_permutation=permutations(vertex)
    for i in next_permutation:
        current_pathweight = 0
        k = s
        for j in i:
            current_pathweight += graph[k][j]
            k = j
        current_pathweight += graph[k][s]
        min_path = min(min_path, current_pathweight)
    return min_path
def Retonar_Conjunto(pos,depart,lista):
  lista_ub=[]
  for i in range(len(lista)):
    if depart==lista[i][0]:
      lista_ub.append(lista[i][pos])
  return lista_ub

def Agregar_a_lista_CP(lista_todos,lista_centros,distrit):
  for i in range(len(lista_todos)):
    if distrit==lista_todos[i][2]:
      lista_centros.append(lista_todos[i])  

def agregar_distritos_a_lista_ordenada(cantidad,lista_d,lista_ordenada,lista_nombres_d):
  for i in range(len(lista_d)):
    for j in range(cantidad):
      if (lista_d[i][2]==lista_nombres_d[j]):
        lista_ordenada[j].append(lista_d[i])

leer_hoja(lista_todos)

#@title Departamento
#@markdown Seleccione un departamento
departamento = "TUMBES"  #@param ["AMAZONAS","ANCASH","APURIMAC","AREQUIPA","AYACUCHO","CAJAMARCA","CUSCO","HUANCAVELICA","HUANUCO","ICA","JUNIN","LA LIBERTAD","LAMBAYEQUE","LIMA","LORETO","MADRE DE DIOS","MOQUEGUA","PASCO","PIURA","PUNO","SAN MARTIN","TACNA","TUMBES","UCAYALI"]

# MUESTRA TODAS LAS PROVINCIAS DEL DEPARTAMENTO
Conjunto=Retonar_Conjunto(1,departamento,lista_todos)
print(set(Conjunto))

#@title Provincia
#@markdown seleccione una provincia del conjunto de provincias:
provincia = 'ZARUMILLA'  #@param {type: "string"}

lista_distrit=[]
conjunto_de_distritos=agregar_todos_distritos(departamento,provincia,lista_todos,lista_distrit)
conjunto_de_nombres_distritos=set(conjunto_de_distritos)
lista_de_nombres_distritos= list (conjunto_de_nombres_distritos)
cantidad_de_distritos=len(set(conjunto_de_distritos))
lista_ordenada_de_distritos=[[]for i in range(cantidad_de_distritos)]
agregar_distritos_a_lista_ordenada(cantidad_de_distritos,lista_distrit,lista_ordenada_de_distritos,lista_de_nombres_distritos)

#MUESTRA UNA LISTA CON MAS LISTAS INCORPORADAS, CADA LISTA INCORPORARDA TIENE LOS DATOS DE LOS CENTROS POBLADOS QUE HAY EN UN DISTRITO (DENTRO DE LA PROVINCIA SELECCIONADA)
for i in lista_ordenada_de_distritos:
  print(i)

G=nx.Graph()
MATRIZ=[]
for i in range (len(lista_ordenada_de_distritos)):
  matriz_conex=[]
  matriz_conex=[[0 for _ in range(len(lista_ordenada_de_distritos[i]))]for _ in range (len(lista_ordenada_de_distritos[i]))]
  for j in range(len(lista_ordenada_de_distritos[i])):
    for k in range(len(lista_ordenada_de_distritos[i])):
       distancia=distancia_puntos(lista_ordenada_de_distritos[i][j],lista_ordenada_de_distritos[i][k])
       matriz_conex[j][k]=distancia
      
  MATRIZ.append(matriz_conex)
for i in range(len(lista_distrit)):
    G.add_node(lista_distrit[i][3])
for i in range(len(MATRIZ)):
  for j in range(len(MATRIZ[i])):
    for k in range(len(MATRIZ[i])):
      if (j!=k):
        G.add_edge(lista_ordenada_de_distritos[i][j][3],lista_ordenada_de_distritos[i][k][3],weight=MATRIZ[i][j][k])

for i in range(len(MATRIZ)):
  print(lista_de_nombres_distritos[i],"-> ",MATRIZ[i])
for i in range(len(MATRIZ)):
  camino=TSP(MATRIZ[i],0)
  print(f"El mejor camino para el distrito {lista_de_nombres_distritos[i]} es de {camino} km")
#for i in MATRIZ:
 # print(i)
gs.nx2gv(G,weighted=True,params={"size":"40"})